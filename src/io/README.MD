# BIO
blocking io
就是服务端有一组线程来处理各个来的请求
然后在处理接收IO期间线程无法被其他人使用
在JDK 1.0的时候就有了

# NIO
同步非阻塞IO, 在JDK 1.4的时候引入， 采用轮询的方式查看数据是否准备好了。
一个Selector监控多个channel的多个事件, 有满足的事件发生时, 便提交到异步的线程池里面去处理.


# TCP中的粘包问题
实际在使用bytebuffer时 并不知道数据是否读完了
就像在TCP协议中, 网络接口底层本身就会缓存后一起发送.
也就是说一条消息的结尾可能和另一条消息的开始在一个packet里面.

那么我们如何保证客户端读完了数据了呢?
比如client发送了100字节, 又发送了100字节, 服务端并不一定会分别收到2个100字节.
原因: 
1. 操作系统本身可能就会出于网络效率的考虑而会收集多个包之后一起发送.
2. TCP本身就是流式连接 并没有一个区分不同数据包的方式.
      
解决方式:
1. 短连接, 发一次消息完成后就断开连接.

2. 长连接:<br>
  (1) 消息定长, 如果我们知道消息有多长就每次读那么长就可以了.<br>
  (2) 不定长, 就每次在发送消息时, 写入消息的长度, 类似于TLV协议.<br>
        a. 在使用这种方式时, 必须要保证提前读取到消息的长度<br>
        b. 并且验证消息长度是否合法.<br>
        c. 处理完一个消息后,注意检查当前是否读取了下一条消息的部分内容, 如果有的话应该要从头开始读取消息长度, 接着处理.<br>

